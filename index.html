<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/MySQL%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Liu Rong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/MySQL%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/" itemprop="url">MySQL语法整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-25T10:15:40+08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>emmm，我花了两天的时间把《MySQL必知必会》过了一遍，因为我记忆力比较差，看完就会忘，所以只能用这种笨方法把它大致写一下留点印象，我这个文章把基本的语法和例子都写了一下（当然表名列名会有乱起的情况…），可以当个<strong>查询手册</strong>来使用，就用Ctrl+F就好了，我读的pdf版可能不太正规用这种方法检索不到任何信息…在这个手册中，游标、触发器以及事务管理我没有记录，主要是太多了，我太懒了…就这样吧，以后可能会补充进来。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;选择数据库  </span><br><span class="line">SHOW  databases;返回可用数据库的一个列表（可能有mysql内部使用的一个列表，如mysql和information_schema）  </span><br><span class="line">SHOW tables;获得一个数据库内的表的列表</span><br><span class="line">SHOW COLUMNS from customers;要求给出一个表名（from customers），它用来显示表列  </span><br><span class="line">SHOW COLUMNS=DESCRIBE</span><br><span class="line">SHOW GRANTS显示授予用户的安全权限</span><br></pre></td></tr></table></figure>
<h2 id="SELECT语句检索单个表列、多个表列以及所有表列"><a href="#SELECT语句检索单个表列、多个表列以及所有表列" class="headerlink" title="SELECT语句检索单个表列、多个表列以及所有表列"></a>SELECT语句检索单个表列、多个表列以及所有表列</h2><p>SELECT prod_name FROM products 从products表中检索一个名为prod_name的列<br>SELECT prod_id,prod_name,prod_price FROM products检索多个列<br>SELECT * FROM products;通过通配符<em>检索所有的列<br>SELECT DISTINCT vend_id FROM products; DISTINCT独特的，通过该关键字返回不同值的行，*</em>必须放在列名前面**，而且它适用于所有的列，不能作用于不同列<br>SELECT prod_name FROM products LIMIT 5; 返回不多于5行，LIMIT总是从第一行开始<br>SELECT prod_name FROM products LIMIT 5,5;指示mysql返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数<br>行0 检索出来的第一行为行0而不是行1，因此，LIMIT 1,1检索出第二行而不是第一行<br>LIMIT 4 OFFSET 3  = LIMIT 3,4 从行3开始取4行<br>SELECT products.prod_name FROM crashcourse.rpoducts;使用完全限定的表名来引用列</p>
<h2 id="排序检索数据（使用ORDER-BY子句排序检索出来的数据）"><a href="#排序检索数据（使用ORDER-BY子句排序检索出来的数据）" class="headerlink" title="排序检索数据（使用ORDER BY子句排序检索出来的数据）"></a>排序检索数据（使用ORDER BY子句排序检索出来的数据）</h2><h2 id="子句（clause-：SQL语句由子句构成，一个关键字-数据-如SELECT语句的FROM-…子句"><a href="#子句（clause-：SQL语句由子句构成，一个关键字-数据-如SELECT语句的FROM-…子句" class="headerlink" title="子句（clause)：SQL语句由子句构成，一个关键字+数据 如SELECT语句的FROM …子句  "></a>子句（clause)：SQL语句由子句构成，一个关键字+数据 如SELECT语句的FROM …子句  </h2><p>SELECT prod_name FROM products ORDER BY prod_name;ORDER BY子句指示prod_name列以字母顺序排序  </p>
<p>SELECT prod_name,prod_price,prod_id FROM products ORDER BY prod_price,prod_name;先按价格排序，如果出现多个<strong>行</strong>价格相同的再按名称排序，<strong>这是按多个列排序</strong>  </p>
<p><strong>指定排序方向</strong> 默认升序，从A到Z，用ORDER BY从Z到A降序，指定DESC关键字(descend)  </p>
<p>SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC;  </p>
<p><strong>DESC只应用到直接位于其前面的列名，对多个列进行升降序时必须对每个列指定DESC关键字</strong>  </p>
<p>SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC,prod_name;先对产品降序排序，再对产品名排序（默认升序）  </p>
<p><strong>ASC(ASCENDING)与DESC相反的关键字，但默认是ASC</strong><br><strong>在字典排序顺序中，A被视为与a相同</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过ORDER BY + LIMIT 找出一个列中最高或最低的值</span><br><span class="line">SELECT prod_price</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC</span><br><span class="line">LIMIT 1;//仅返回一行</span><br><span class="line">顺序：ORDER BY 必须在FROM 后，LIMIT 必须在ORDER BY 后</span><br></pre></td></tr></table></figure>
<h2 id="过滤数据-WHERE子句-在FROM子句后给出"><a href="#过滤数据-WHERE子句-在FROM子句后给出" class="headerlink" title="过滤数据(WHERE子句)  在FROM子句后给出"></a>过滤数据(WHERE子句)  在FROM子句后给出</h2><p>SELECT prod_name,prod_price FROM products WHERE prod_price=2.50;//返回price=2.5的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WHERE子句操作符</span><br><span class="line">=</span><br><span class="line">&lt;&gt;不等于</span><br><span class="line">!=不等于</span><br><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;</span><br><span class="line">&gt;=</span><br><span class="line">BETWEEN在指定的两个值之间</span><br></pre></td></tr></table></figure>
<p>SELECT prod_name,prod_price FROM products WHERE prod_name=’fuses’; <strong>检查WHERE prod_name=’fuses’子句时，默认不区分大小写，fuses可与Fuses匹配</strong><br>SELECT prod_id,prod_price FROM products WHERE prod_id &lt;&gt;1003;列出不是由供应商1003制造的所有产品<br>SELECT prod_name,prod_price FROM products BETWEEN 5 AND 10; BETWEEN匹配范围中所有的值，包括指定的开始值和结束值<br><strong>空值检查</strong>在一个列不包含值时，称其为包含空值NULL<br><strong>NULL 无值(no value)</strong>它与字段包含0，空字符串，空格 不同<br>SELECT prod_name FROM products WHERE prod_price IS NULL; IS NULL子句用来检查具有NULL值的列  </p>
<h2 id="数据过滤（NOT-IN-操作符）"><a href="#数据过滤（NOT-IN-操作符）" class="headerlink" title="数据过滤（NOT IN 操作符）"></a>数据过滤（NOT IN 操作符）</h2><p>操作符：用来联结或改变WHERE子句中的子句的关键字</p>
<ol>
<li>AND操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,prod_price,prod_name FROM products WHERE vend_id=1003 AND prod_price&lt;=10;</span><br></pre></td></tr></table></figure></li>
<li>OR操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,prod_price FROM products WHERE vend_id=1003 OR vend_id=1002;//OR操作符匹配任一条件的行</span><br></pre></td></tr></table></figure></li>
<li>优先级AND&gt;OR<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,prod_price FROM products WHERE vend_id=1002 OR vend_id=1003 AND prod_price&gt;=10;</span><br><span class="line">被理解成了id=1003且价格大于10的产品  和  id1002的产品</span><br><span class="line">用（）解决</span><br><span class="line">SELECT prod_name,prod_price FROM products WHERE (vend_id=1002 OR vend_id=1003) AND prod_price&gt;=10;</span><br></pre></td></tr></table></figure></li>
<li>IN(指定条件范围)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name;</span><br><span class="line"></span><br><span class="line">IN与OR完成相同的功能，但IN更好，IN能包含其他SELECT语句</span><br></pre></td></tr></table></figure></li>
<li>NOT(否定它之后的任何条件) WHERE子句中用来否定后跟条件的关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN (1002,1003) ORDER BY prod_name;</span><br><span class="line">MySQL支持对IN,BETWEEN,EXISTS子句取反</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="用通配符进行过滤（LIKE操作符）"><a href="#用通配符进行过滤（LIKE操作符）" class="headerlink" title="用通配符进行过滤（LIKE操作符）"></a>用通配符进行过滤（LIKE操作符）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wildcard 用来匹配值的一部分的特殊字符</span><br><span class="line">search pattern 由字面值、通配符或两者组合构成的搜索条件</span><br><span class="line">LIKE是谓词predicate而不是操作符，虽然最终的结果是相同的</span><br></pre></td></tr></table></figure>
<ol>
<li>%通配符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">表示任何字符出现任意次数</span><br><span class="line">SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;jet%&apos;;结果可以是jet123...,只要开头是jet就行</span><br><span class="line">MySQL可以区分大小写</span><br><span class="line">%jet%</span><br><span class="line">s%e以s开头e结尾</span><br><span class="line">%还能匹配0个字符，0，1，。。。多个字符</span><br><span class="line">尾空格可能会干扰通配符匹配</span><br><span class="line"></span><br><span class="line">%不能匹配用值NULL作为产品名的行</span><br><span class="line">WHERE prod_name LIKE &apos;%&apos;</span><br></pre></td></tr></table></figure></li>
<li>_通配符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下划线_匹配单个字符，不能多也不能少</span><br><span class="line">SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;_jet&apos;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h2><p>正则表达式是用来匹配文本的特殊的串（字符集合）<br>它的作用是匹配文本</p>
<ol>
<li><p>基本字符匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;1000&apos; ORDER BY prod_name;</span><br><span class="line"></span><br><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;.000&apos; ORDER BY prod_name;//.表示匹配任意一个字符，1000和2000都匹配返回</span><br><span class="line"></span><br><span class="line">LIKE用来匹配整个列值，REGEXP可以匹配部分列值，也可以匹配整个列值</span><br><span class="line">REGEXP不区分大小写，可使用BINARY关键字区分大小写</span><br><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP BINARY &apos;JetPack.000&apos;;</span><br></pre></td></tr></table></figure></li>
<li><p>OR匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.相当于_</span><br><span class="line">|相当于OR</span><br><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;1000|2000&apos;;</span><br></pre></td></tr></table></figure></li>
<li><p>匹配几个字符[] 另一种形式的OR</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[123] 匹配1或2或3的意思</span><br><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[123] Ton&apos;;</span><br><span class="line">结果 1 ton /2 ton</span><br></pre></td></tr></table></figure></li>
<li><p>^否定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^123]匹配除这些字符外的任何东西</span><br></pre></td></tr></table></figure></li>
<li><p>匹配范围 -</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9]=[0123456789]/[a-z]</span><br></pre></td></tr></table></figure></li>
<li><p>匹配特殊字符 . </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以\\为前导,\\-表示查找-,\\.表示查找.</span><br><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;\\.&apos;;</span><br><span class="line">转义escaping</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配多个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;\\([0-9] sticks?\\)&apos;;//?表明它前面的s可以有可以无</span><br><span class="line"></span><br><span class="line">SELECT prod_name FROM products WHERE prod_name REGEXP &apos;[[:digit:]]&#123;4&#125;&apos;;//相当于&apos;[0-9][0-9][0-9][0-9]&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定位符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">^ 文本的开始</span><br><span class="line">$ 文本的结尾</span><br><span class="line">[[:&lt;:]] 词的开始</span><br><span class="line">[[:&gt;:]] 词的结尾</span><br><span class="line"></span><br><span class="line">寻找以一个数开始的产品(包括小数点)</span><br><span class="line">REGEXP &apos;^[0-9\\.]&apos;</span><br><span class="line"></span><br><span class="line">^放在[]外代表串的开始处，放在[^]里代表否定该集合</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>计算字段是运行时在SELECT语句内创建的,并不实际存在于数据库<br>字段和列的意思基本相同，不过数据库列称为列，计算字段称为字段</p>
<ol>
<li>拼接字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拼接concatenate 将值联结到一起构成单个值  使用Concat()函数</span><br><span class="line">SELECT Concat(vend_name,&apos; (&apos;,vend_country,&apos;)&apos;) FROM vendors ORDER BY vend_name;</span><br><span class="line"></span><br><span class="line">Concat()拼接串，即把多个串连接起来形成一个较长的串，用,分隔</span><br><span class="line">RTrim() 删除数据右侧多余的空格来整理数据</span><br><span class="line">SELECT Concat(RTrim(vend_name),&apos; (&apos;,vend_country,&apos;)&apos;) FROM vendors ORDER BY vend_name;</span><br><span class="line">LTrim()去掉左边空格</span><br><span class="line">Trim()去掉左右空格</span><br></pre></td></tr></table></figure></li>
<li>别名 alias<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个字段的替换名</span><br><span class="line">AS关键字</span><br><span class="line">SELECT Concat(RTrim(vend_name),&apos; (&apos;,vend_country,&apos;)&apos;) AS vend_title FROM vendors ORDER BY vend_name;</span><br><span class="line"></span><br><span class="line">别名也称导出列</span><br><span class="line"></span><br><span class="line">quantity*item_price AS expanded_price</span><br><span class="line"></span><br><span class="line">SELECT Now() 返回当前日期和时间</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><ol>
<li>文本处理函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name,Upper(vend_name) AS vend_name_upcase FROM vendors ORDER BY vend_name;</span><br></pre></td></tr></table></figure></li>
<li>日期和时间处理函数<br>格式yyyy-mm-dd<br>SELECT cust_id,order_num FROM orders WHERE order_date=’2005-09-01’;<br>Date(order_date)=’2005-09-01’;<br>Date()指示仅提取列的日期部分<br>Date(order_date) BETWEEN ‘2005-09-01’ AND ‘2005-09-30’;</li>
</ol>
<h2 id="汇总数据（聚集函数）"><a href="#汇总数据（聚集函数）" class="headerlink" title="汇总数据（聚集函数）"></a>汇总数据（聚集函数）</h2><p>确定表中行数<br>获得表中行组的和<br>找出表列的最大值、最小值、平均值<br><strong>聚集函数</strong> 运行在行组上，计算和返回单个值的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AVG() 返回某列的平均值</span><br><span class="line">COUNT() 返回某列的行数</span><br><span class="line">MAX()</span><br><span class="line">MIN()</span><br><span class="line">SUM() 返回某列值之和</span><br><span class="line"></span><br><span class="line">SELECT AVG(prod_price) AS avg_price FROM products WHERE prod_id=10;</span><br><span class="line"></span><br><span class="line">AVG()只适用于单个列，AVG()函数忽略列值为NULL的行</span><br><span class="line"></span><br><span class="line">COUNT(*) 不管列中包含的是NULL还是非空值，都计数</span><br><span class="line">COUNT(column)对特定列计数，忽略NULL值</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) AS num_cust FROM customers;</span><br><span class="line"></span><br><span class="line">MAX()函数忽略列值为NULL的行</span><br><span class="line">MIN()函数忽略列值为NULL的行</span><br><span class="line"></span><br><span class="line">SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num=2005;</span><br><span class="line">SUM()函数忽略列值为NULL的行</span><br></pre></td></tr></table></figure>
<p>只包含不同的值，指定DISTINCT参数<br>SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE prod_id=10;<br>DISTINCT 不适用于COUNT(*) 必须指定列名</p>
<p><strong>组合聚集函数</strong><br>SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_pice)AS price_avg FROM products;</p>
<h2 id="分组数据（GROUP-BY子句-和-HAVING子句）"><a href="#分组数据（GROUP-BY子句-和-HAVING子句）" class="headerlink" title="分组数据（GROUP BY子句 和 HAVING子句）"></a>分组数据（GROUP BY子句 和 HAVING子句）</h2><p>分组把数据分为多个逻辑组，以便对每个组进行聚集计算<br><strong>GROUP BY</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对比理解</span><br><span class="line">SELECT COUNT(*) AS num_prods FROM products WHERE prod_id=10;</span><br><span class="line">SELECT prod_id,COUNT(*) AS num_prods FROM products GROUP BY prod_id;//这是对每个prod_id进行一个COUNT(*),对每个组而不是整个结果进行聚集</span><br><span class="line"></span><br><span class="line">GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</span><br></pre></td></tr></table></figure>
<p><strong>HAVING</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HAVING过滤分组，WHERE过滤行</span><br><span class="line">HAVING在数据分组后进行过滤，WHERE在数据分组前进行过滤</span><br><span class="line">WHERE排除的行不包括在分组中，这可能会改变计算值影响HAVING子句</span><br><span class="line"></span><br><span class="line">列出至少由两个订单的所有顾客 GROUP BY 顾客 HAVING 订单&gt;=2</span><br><span class="line">这用WHERE做不出来</span><br><span class="line">SELECT cust_id,COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*)&gt;=2;</span><br><span class="line"></span><br><span class="line">WHERE和HAVING一起使用：返回过去12个月内下过的订单</span><br><span class="line"></span><br><span class="line">列出具有2个以上，价格在10以上的产品的供应商</span><br><span class="line">SELECT vend_id,COUNT(*) SA num_prods FROM products WHERE vend_price&gt;=10 GROUP BY vend_id HAVING COUNT(*)&gt;=2 ORDER BY num_prods;</span><br></pre></td></tr></table></figure>
<p><strong>SELECT子句顺序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure>

<h2 id="子查询（嵌套在其他查询中的查询）"><a href="#子查询（嵌套在其他查询中的查询）" class="headerlink" title="子查询（嵌套在其他查询中的查询）"></a>子查询（嵌套在其他查询中的查询）</h2><p>子查询总是从内向外处理<br>SELECT cust_id FROM orders WHERE order_num IN(SELECT order_num FROM orderitems WHERE prod_id=’TNT2’);<br>作为计算字段使用子查询<br>SELECT cust_name,cust_state,(SELECT COUNT(*) FROM orders WHERE orders.cust_id=customers.cust_id) AS orders FROM customers ORDER BY cust_name;</p>
<h2 id="联结表-join"><a href="#联结表-join" class="headerlink" title="联结表(join)"></a>联结表(join)</h2><p>外键(foreign key)一般是另一个表的主键（primary key)<br>分解数据为多个表能更有效地存储，更方便地处理</p>
<p>维护引用完整性<br>联结是一种机制，用来在一条SELECT语句中关联表<br><strong>创建联结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors,products</span><br><span class="line">WHERE vendors.vend_id=products.vend_id</span><br><span class="line">ORDER BY vend_name,prod_name;</span><br><span class="line">完全限定列名</span><br><span class="line">将第一个表中的每一个行与第二个表中的每一个行配对，where子句作为过滤条件</span><br><span class="line"></span><br><span class="line">笛卡尔积（caresian product) 没有联结条件时返回的结果为笛卡尔积，检索的行的数目将是第一个表中的行数乘以第二个表中的行数</span><br><span class="line"></span><br><span class="line">应保证所有的联结都有WHERE子句</span><br></pre></td></tr></table></figure>
<p><strong>目前为止所用的联结称为等值联结它基于两个表之间的相等测试，也称为内部联结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">与前面的意思相同，但FROM子句语法不同</span><br><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend_id=products.vend_id;</span><br><span class="line"></span><br><span class="line">ANSI SQL规范首选INNER JOIN语法</span><br></pre></td></tr></table></figure>
<p><strong>联结多个表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name,vend_name,prod_price,quantity</span><br><span class="line">FROM orderitems,products,vendors</span><br><span class="line">WHERE products.vend_id=vendors.vend_id</span><br><span class="line">AND orderitems.prod_id=products.prod_id</span><br><span class="line">AND order_num=200;</span><br></pre></td></tr></table></figure>

<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><p>给表起别名，使用聚集函数<br>SELECT cust_name,cust_contact FROM customers AS c,orders AS o,orderitems AS oi WHERE c.cust_id=o.cust_id AND oi.order_num=o.order_num AND prod_id=’TNT2’;<br>//表别名不像列别名一样能返回到结果，只能在查询执行中使用<br><strong>等值联结</strong><br><strong>自联结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">自联结|子查询，前者速度更快</span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id=(SELECT vend_id</span><br><span class="line">                FROM products</span><br><span class="line">                WHERE prod_id=&apos;DTNTR&apos;);</span><br><span class="line"></span><br><span class="line">SELECT p1.prod_id,p1.prod_name</span><br><span class="line">FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id=p2.vend_id</span><br><span class="line">AND p2.prod_id=&apos;DTNTR&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>自然联结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INNER JOIN 返回所有的数据，甚至相同的列多次出现</span><br><span class="line">自然联结排除多次出现，使每个列只返回一次</span><br><span class="line"></span><br><span class="line">该联结通过对表使用通配符SELECT *,对所有其他表的列使用明确的子集来完成的</span><br><span class="line">SELECT c.*,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_price</span><br><span class="line">FROM customers AS c,orders AS o,orderitems AS oi</span><br><span class="line">WHERE c.cust_id=o.cust_id</span><br><span class="line">AND oi.order_num=o.order_num</span><br><span class="line">AND prod_id=&apos;FB&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>外部联结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">许多联结间一个表中的一行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行</span><br><span class="line"></span><br><span class="line">联结包含了那些在相关表中没有关联行的行，这种联结称为外部联结</span><br><span class="line"></span><br><span class="line">内部联结（INNER JOIN）</span><br><span class="line">SELECT customers.cust_id,orders.order_num</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line">ON customers.cust_id=orders.cust_id;</span><br><span class="line"></span><br><span class="line">外部联结（OUTER JOIN)</span><br><span class="line">SELECT customers.cust_id,orders.order_num</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id=orders.cust_id;</span><br><span class="line">检索所有用户，包括没订单的客户，其中会出现cust_id=1001,order_num=NULL的结果</span><br><span class="line"></span><br><span class="line">LEFT OUTER JOIN表示从FROM子句的左边表中选择所有行</span><br><span class="line">RIGHT OUTER JOIN 从右边选</span><br><span class="line">左外部联结可通过颠倒表的顺序转换为右外部联结</span><br></pre></td></tr></table></figure>
<p><strong>使用带聚集函数的联结</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.cust_name,</span><br><span class="line">        customers.cust_id,</span><br><span class="line">        COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line">ON customers.cust_id=orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br><span class="line"></span><br><span class="line">左外部联结会显示一个客户的订单数量为0</span><br></pre></td></tr></table></figure>

<h2 id="组合查询-用UNION操作符将多条SELECT语句组合成一个结果集"><a href="#组合查询-用UNION操作符将多条SELECT语句组合成一个结果集" class="headerlink" title="组合查询(用UNION操作符将多条SELECT语句组合成一个结果集)"></a>组合查询(用UNION操作符将多条SELECT语句组合成一个结果集)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">也称为并（union）或复合查询（compound query）</span><br><span class="line">任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出</span><br><span class="line"></span><br><span class="line">使用情况：</span><br><span class="line">对单个表执行多个查询，按单个查询返回数据</span><br><span class="line">在单个查询中从不同的表返回类似结构的数据</span><br></pre></td></tr></table></figure>
<p><strong>使用UNION</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,prod_id,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price&lt;=5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id,prod_id,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001,1002);</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">WHERE prod_price&lt;=5 OR vend_id IN (1001,1002);</span><br><span class="line"></span><br><span class="line">返回一个结果集</span><br><span class="line">从多个表检索数据时UNION会更简单</span><br><span class="line"></span><br><span class="line">UNION中的每个查询必须包含相同的列、表达式或聚集函数</span><br><span class="line">UNION默认自动去除重复的行，使用UNION ALL而不是UNION改变它</span><br><span class="line">UNION组合查询只能使用一条ORDER BY子句，且必须出现在最后一条SELECT语句之后</span><br><span class="line">使用UNION的组合查询可以应用不同的表</span><br></pre></td></tr></table></figure>

<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><p>不是所有的数据库引擎都支持全文本搜索，MyTSAM支持,InnoDB不支持<br>通配符和正则表达式都存在重要的限制<br>MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行<br><strong>启用全文本搜索支持</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建表时启用，CREATE TABLE 语句接收FULLTEXT子句，他给出被索引列的一个逗号分隔的列表</span><br><span class="line">CREATE TABLE products</span><br><span class="line">(</span><br><span class="line">    note_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">    prod_id char(10) NOT NULL,</span><br><span class="line">    note_text text NULL,</span><br><span class="line">    PRIMARY KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">)ENGING=MyISAM;</span><br><span class="line">定义后，MySQL自动维护该索引。在增加、更新、删除行时，索引随之自动更新</span><br><span class="line"></span><br><span class="line">应该先导入数据再修改表定义FULLTEXT,因为更新索引要花时间</span><br></pre></td></tr></table></figure>
<p><strong>进行搜索</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在索引后，使用函数Match()指定被索引的列和Against()指定要索引的内容</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM products</span><br><span class="line">WHERE Match(note_text) Against(&apos;rabbit&apos;);</span><br><span class="line">传给Match()的值必须与FULLTEXT()定义中的相同,如果指定多个列，则次序必须相同</span><br><span class="line">搜索不区分大小写，除非使用BINARY</span><br><span class="line">用LIKE  WHERE note_text LIKE &apos;%rabbit%&apos;;</span><br><span class="line"></span><br><span class="line">全文本搜索会对结果排序，具有较高等级的行先返回</span><br><span class="line"></span><br><span class="line">返回等级值(不含rabbit返回0)</span><br><span class="line">SELECT note_text,Match(note_text) Against(&apos;rabbit&apos;) AS rank</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<p><strong>查询扩展</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">扩大搜索范围</span><br><span class="line">1.首先，进行一个基本的全文本搜索，找出匹配的所有行</span><br><span class="line">2.从找出的所有行中找到有用的词</span><br><span class="line">3.用这些词+原来的词再去匹配所有行</span><br><span class="line"></span><br><span class="line">SELECT note_text</span><br><span class="line">FROM products</span><br><span class="line">WHERE Match(note_text) Against(&apos;anvils&apos; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>
<p><strong>布尔文本搜索</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1要匹配的词</span><br><span class="line">2要排斥的词</span><br><span class="line">3指定那些词等级更高</span><br><span class="line">4表达式分组</span><br><span class="line">5另外一个内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT note_text</span><br><span class="line">FROM products</span><br><span class="line">WHERE Match(note_text) Against(&apos;anvils&apos; IN BOOLEAN MODE);</span><br><span class="line"></span><br><span class="line">为了匹配包含heavy但不包含rope的</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM products</span><br><span class="line">WHERE Match(note_text) Against(&apos;heavy -rope*&apos; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>

<h2 id="插入数据-INSERT语句"><a href="#插入数据-INSERT语句" class="headerlink" title="插入数据 (INSERT语句)"></a>插入数据 (INSERT语句)</h2><p>SELECT/INSERT/UPDATE/DELETE都是最常使用的SQL语句<br>INSERT <strong>LOW_PRIORITY</strong> INTO 降低INSERT语句的优先级，因为INSERT操作很耗时</p>
<p><strong>插入完整的行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定表名和插入到新行的值</span><br><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(NULL,&apos;aaa&apos;,&apos;bbb&apos;,&apos;USA&apos;,NULL,NULL);</span><br><span class="line">第一列cust_id右MySQL自动增量</span><br></pre></td></tr></table></figure>
<p><strong>插入行的一部分</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">还可以这样写，更安全</span><br><span class="line">INSERT INTO Customers(cust_id,cust_name,cust_country,cust_zip,cust_city)</span><br><span class="line">VALUES(NULL,&apos;aaa&apos;,&apos;bbb&apos;,&apos;USA&apos;,NULL,NULL);</span><br></pre></td></tr></table></figure>
<p><strong>插入多行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(NULL,&apos;aaa&apos;,&apos;bbb&apos;,&apos;USA&apos;,NULL,NULL),</span><br><span class="line">(NULL,&apos;ccc&apos;,&apos;ddd&apos;,&apos;USA&apos;,NULL,NULL);</span><br></pre></td></tr></table></figure>
<p><strong>插入某些查询的结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将一条SELECT语句的结果插入表中</span><br><span class="line"></span><br><span class="line">INSERT INTO customers</span><br><span class="line">(cust_id,</span><br><span class="line">cust_email,</span><br><span class="line">cust_name,</span><br><span class="line">cust_city)</span><br><span class="line">SELECT cust_id,</span><br><span class="line">       cust_email,</span><br><span class="line">       cust_name,</span><br><span class="line">       cust_city</span><br><span class="line">FROM custnew;</span><br><span class="line">要确保主键cust_id不一样，或者把它删了让系统自动填充</span><br></pre></td></tr></table></figure>

<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><p><strong>更新（修改）数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">要更新的表</span><br><span class="line">列名和新值</span><br><span class="line">更新行的过滤条件</span><br><span class="line"></span><br><span class="line">更新特定行</span><br><span class="line">*不要省略WHERE子句，不然很容易更新所有行</span><br><span class="line">UPDATE products</span><br><span class="line">SET cust_email=&apos;123&apos;</span><br><span class="line">WHERE cust_id=100;</span><br><span class="line"></span><br><span class="line">更新多个列</span><br><span class="line">UPDATE products</span><br><span class="line">SET cust_email=&apos;123&apos;,</span><br><span class="line">    cust_name=&apos;xiu&apos;</span><br><span class="line">WHERE cust_id=100;</span><br><span class="line"></span><br><span class="line">发生错误也继续更新采用IGNORE关键字</span><br><span class="line">UPDATE IGNORE products</span><br><span class="line"></span><br><span class="line">删除某个列把它设置成NULL</span><br><span class="line"></span><br><span class="line">更新所有行</span><br></pre></td></tr></table></figure>
<p><strong>删除数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">删除整行</span><br><span class="line">DELETE FROM products</span><br><span class="line">WHERE cust_id=100;</span><br><span class="line">不带WHERE子句全部清除</span><br><span class="line"></span><br><span class="line">想删除指定的列使用UPDATE</span><br><span class="line"></span><br><span class="line">删除的是表的内容但不是表本身</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除所有行使用TRUNCATE TABLE语句，TRUNCATE实际上是删除原来的表并重新创建一个表</span><br></pre></td></tr></table></figure>

<h2 id="创建和操纵表-CREATE-TABLE"><a href="#创建和操纵表-CREATE-TABLE" class="headerlink" title="创建和操纵表(CREATE TABLE)"></a>创建和操纵表(CREATE TABLE)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.新表的名字在CREATE TABLE后给出</span><br><span class="line">2.表列的名字和定义用逗号分割</span><br><span class="line">列名+列的数据类型</span><br><span class="line"></span><br><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">    cust_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">    cust_name char(50) NOT NULL,</span><br><span class="line">    ...,</span><br><span class="line">    PRIMARY KEY(cust_id)</span><br><span class="line">)ENDINE=InnoDB</span><br><span class="line">MySQL语句忽略空格</span><br><span class="line"></span><br><span class="line">创建新表时，指定的表明必须不存在</span><br><span class="line"></span><br><span class="line">在不存在时创建它，在表名后加IF NOT EXISTS</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">所有列要么是NULL或者NOT NULL</span><br><span class="line">NULL是默认设置</span><br><span class="line">NULL是没有值，他不是空串,&apos;&apos;在NOT NULL列中是允许的,空串是一个有效的值，不是无值</span><br><span class="line"></span><br><span class="line">主键使用单个列或多个列则组合值必须唯一</span><br><span class="line">主键是唯一标志表中每个行的列，主键只能使用不允许NULL值的列。</span><br><span class="line"></span><br><span class="line">AUTO_INCREMENT告诉MySQL本列每增加一行时自动增量</span><br><span class="line"></span><br><span class="line">每个表制允许一个AUTO_INCREMENT列，而且它必须被索引（通过使它成为主键）</span><br><span class="line"></span><br><span class="line">SELECT last_insert_id 将返回最后一个AUTO_INCREMENT值</span><br></pre></td></tr></table></figure>
<p><strong>指定默认值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用DEFAULT关键字指定</span><br><span class="line"></span><br><span class="line">quantity int NOT NULL DEFAULT 1, 在未给出数量的情况下使用1</span><br><span class="line"></span><br><span class="line">引擎：InnorDB支持事物处理</span><br><span class="line">MEMORY 相当于MyISAM,数据存储在内存中，速度快</span><br><span class="line">MyISAM支持全文本搜索，但不支持事务处理</span><br></pre></td></tr></table></figure>

<p><strong>更新表定义</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE</span><br><span class="line"></span><br><span class="line">1. 添加一个列</span><br><span class="line">ALTER TABLE vendors</span><br><span class="line">ADD vend_phone CHAR(20);</span><br><span class="line"></span><br><span class="line">2. 删除刚添加的列</span><br><span class="line">ALTER TABLE vendors</span><br><span class="line">DROP COLUMN vend_phone;</span><br><span class="line"></span><br><span class="line">3.ALTER TABLE 常用来定义外键(constraint 约束)</span><br><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders(order_num);</span><br></pre></td></tr></table></figure>
<p><strong>删除表</strong><br>DROP TABLE customers;<br><strong>重命名表</strong><br>RENAME customers TO customer1,<br>       customer2 TO customer3;  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 创建新表</span><br><span class="line">ALTER TABLE 更改表列</span><br><span class="line">DROP TABLE 完整的删除一个表</span><br></pre></td></tr></table></figure>

<h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p><strong>视图是虚拟的表</strong>，与包含数据的表不一样，视图只包含使用时动态检索数据的查询<br>作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询<br><strong>使用视图</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">视图用CREATE VIEW语句来创建</span><br><span class="line">使用SHOW CREATE VIEW viewname;来查看创建视图的语句</span><br><span class="line">删除视图 DROP VIEW viewname;</span><br><span class="line">更新视图时，可以先用DROP再用CREATE，或CREATE OR REPLACE VIEW</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建一个productcustomers的视图</span><br><span class="line">CREATE VIEW productcustomers AS</span><br><span class="line">SELECT cust_name,cust_contact,prod_id</span><br><span class="line">FROM customers,orders,orderitems</span><br><span class="line">WHERE customers.cust_id=orders.cust_id</span><br><span class="line">AND orderitems.order_num=orders.order_num;</span><br><span class="line"></span><br><span class="line">使用视图</span><br><span class="line">SELECT cust_id,cust_name</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id=&apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>视图是可更新的，可以使用INSERT\UPDATE和DELETE</strong><br>更新一个视图将更新其基表，因为视图本身没有数据，MySQL不能正确的确定被更新的基数据时，不允许更新（包括INSERT、DELETE）<br>有一下操作就不能进行更新<br>分组（GROUP BY和HAVING）<br>联结<br>子查询<br>并<br>聚集函数<br>DISTINCT<br>导出（计算）列  </p>
<p>一般视图是用来检索SELECT的，不用于更新，它包含的不是数据，是需要检索数据的查询  </p>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p><strong>存储过程就是为以后的使用而保存的一条或多条MySQL语句的集合，类似于批处理文件。特点：简单、安全、高性能，但它的创建权限可能会被限制，但允许使用存储过程</strong></p>
<ol>
<li><p>执行存储过程(调用=CALL)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CALL接受存储过程的名字以及传递给它的任意参数</span><br><span class="line"></span><br><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br><span class="line">执行名为productpricing的存储过程，它计算并返回产品的最低、最高、平均价格</span><br><span class="line">存储过程可以显示结果，也可以不显示</span><br></pre></td></tr></table></figure></li>
<li><p>创建存储过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">    FROM products;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">接收参数的话再（）中列出</span><br><span class="line">BEGIN/END语句限定存储过程体</span><br><span class="line"></span><br><span class="line">使用MySQL命令行程序时，要把语句结束分隔符;暂时改成其他的（如//)，不然存储过程内容会出错</span><br><span class="line">使用DELIMITER （定界符）</span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">    FROM products;</span><br><span class="line">END//</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">除\符号，其他都可作为语句分隔符</span><br><span class="line"></span><br><span class="line">CALL productpricing();</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储过程<br>DROP PROCEDURE productpricing;//后面无（），只有过程名<br>仅当存在时删除 DROP PROCEDURE IF EXISTS</p>
</li>
<li><p>使用参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">变量 内存中一个特定的位置，用来临时存储数据</span><br><span class="line"></span><br><span class="line">OUT指出该参数用来从存储过程传出一个值（给调用者</span><br><span class="line">IN（传给存储过程</span><br><span class="line">INOUT（传入传出</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">    OUT p1 DECIMAL(8,2),</span><br><span class="line">    OUT ph DECIMAL(8,2),</span><br><span class="line">    OUT pa DECIMAL(8,2),</span><br><span class="line">    IN number INT</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Min(...)</span><br><span class="line">    INTO p1</span><br><span class="line">    FROM ...;</span><br><span class="line">    SELE...</span><br><span class="line">    ...</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL productpricing(@...,@...,@priceaverage,1234);</span><br><span class="line"></span><br><span class="line">//检索平均价格</span><br><span class="line">SELECT @priceaverage;</span><br></pre></td></tr></table></figure>
</li>
<li><p>智能存储过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">186</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><ol>
<li>访问控制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户应该对它们需要的数据具有适当的访问权</span><br><span class="line"></span><br><span class="line">MySQL创建一个名为root的用户账号，他对整个服务器有完全的控制，再现实工作中应该创建一系列账号，有的用于管理，有的给开发人员使用</span><br></pre></td></tr></table></figure></li>
<li>管理用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MySQL用户账号和信息存储再名为mysql的数据库中，mysql中有一个名为user的表，它包含所有用户账号，user表有一列名为user的列，它存储用户登录名</span><br><span class="line"></span><br><span class="line">USE mysql;</span><br><span class="line">SELECT user FROM user;</span><br><span class="line"></span><br><span class="line">创建用户账号</span><br><span class="line">CREATE USER kang IDENTIFIED BY &apos;p@ssword&apos;;</span><br><span class="line">指定散列口令 IDENTIFIED BY PASSWORD</span><br><span class="line">IDENTIFIED BU 指定的口令为纯文本</span><br><span class="line"></span><br><span class="line">使用GRANT和INSERT GRANT语句也可以创建用户账户，但CREATE USER是最清晰的</span><br><span class="line"></span><br><span class="line">重命名账户</span><br><span class="line">RENAME kang TO liu;</span><br><span class="line"></span><br><span class="line">删除用户账号</span><br><span class="line">DROP USER kang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">看到用户账号的权限</span><br><span class="line">SHOW GRANTS FOR kang; 结果 GRANT USAGE on *.* TO ...</span><br><span class="line">USAGE表示没有任何权限</span><br><span class="line"></span><br><span class="line">用户定义为user@host</span><br></pre></td></tr></table></figure></li>
<li>设置权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用GRANT语句</span><br><span class="line"></span><br><span class="line">要授予的权限</span><br><span class="line">被授予访问权限的数据库和表</span><br><span class="line">用户名</span><br><span class="line"></span><br><span class="line">GRANT SELECT ON crashcourse.* TO kang;//允许用户在crashcourse数据库的所有表上使用SELECT访问权限</span><br><span class="line"></span><br><span class="line">取消权限REVOKE</span><br><span class="line">REVOKE SELECT ON crashcourse.* FROM kang;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="串数据类型"><a href="#串数据类型" class="headerlink" title="串数据类型"></a>串数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定长串/变长串</span><br><span class="line"></span><br><span class="line">CHAR</span><br><span class="line"></span><br><span class="line">ENUM</span><br><span class="line">LONGTEXT</span><br><span class="line">MEDIUMTEXT</span><br><span class="line">SET</span><br><span class="line">TEXT</span><br><span class="line">TINYTEXT</span><br><span class="line">VARCHAR</span><br></pre></td></tr></table></figure>

<h2 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">除BIT和BOOLEAN外都可以有符号或无符号（UNSIGNED课存储两倍大小的值）</span><br><span class="line"></span><br><span class="line">BIT</span><br><span class="line">BIGINT</span><br><span class="line">BOOLEAN</span><br><span class="line">DECIMAL 精度可变的浮点值，存储货币一般使用DECIMAL(8,2)</span><br><span class="line">DOUBLE</span><br><span class="line">FLOAT</span><br><span class="line">INT</span><br><span class="line">MEDIUMINT</span><br><span class="line">REAL 4字节的浮点值</span><br><span class="line">SMALLINT</span><br><span class="line">TINYINT</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DATE 格式为YYYY-MM-DD</span><br><span class="line">DATETIME</span><br><span class="line">TIMESTAMP 功能与DATETIME相同，但范围小</span><br><span class="line">TIME 格式为HH:MM:SS</span><br><span class="line">YEAR 2位或4位数字表示</span><br></pre></td></tr></table></figure>

<h2 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLOB</span><br><span class="line">MEDIUMBLOB</span><br><span class="line">LONGBLOB</span><br><span class="line">TINYBLOB</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Liu Rong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/06/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3/" itemprop="url">完全背包问题求解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-06T19:54:17+08:00">
                2019-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><pre><code>给定载重量为M的背包和n种物品，每种物品有一定的重量和价值，现在需要设计算法，在不超过背包载重量的前提下，巧妙选择物品，使得装入背包的物品的总价值最大化。规则是，每种物品均可装入背包多次或不装入（但不能仅装入物品的一部分）。请用数学语言对上述背包问题加以抽象，在此基础上给出动态规划求解该问题的递归公式，采用熟悉的程序设计语言实现“广义背包问题”的求解。在成果展示与课程报告中要求对所给公式中的符号意义加以详细说明，并简述算法的求解步骤</code></pre><h1 id="问题背景与分析"><a href="#问题背景与分析" class="headerlink" title="问题背景与分析"></a>问题背景与分析</h1><pre><code>广义（完全）背包问题是01背包问题的加强版。
在01背包问题中我们对所给的物品的数量是有限制的，你也可以认为每件商品都是独一无二的，每一件物品最多只能选择一次，即在背包中该物品只有存在（1）与不存在（0）两种状态
在广义背包问题中每种物品均可装入背包多次，它的含义就是每种商品可以是无限数量的。举个例子，在极端情况下，有个物品所占背包空间最少，而且它的价值最高。那么你可以用这一种物品把背包装满，当然，此情况下背包空间是可被物品所需空间整除的！</code></pre><h2 id="重点：每种物品有无数件"><a href="#重点：每种物品有无数件" class="headerlink" title="重点：每种物品有无数件"></a>重点：<strong>每种物品有无数件</strong></h2><h1 id="变量假设"><a href="#变量假设" class="headerlink" title="变量假设"></a>变量假设</h1><table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M</td>
<td align="center">背包容量</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">物品种类</td>
</tr>
<tr>
<td align="center">Si</td>
<td align="center">第i种物品所需空间</td>
</tr>
<tr>
<td align="center">Vi</td>
<td align="center">第i种物品的价值</td>
</tr>
</tbody></table>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p><strong>简化运算</strong></p>
<ol>
<li>去掉Si&gt;M的超容量物品</li>
<li>由问题分析部分可得每种物品数量不限可重复装入，那么我们可以明白一点：若某物品（i）优于某部分物品（j，K，l…)，则可去除该部分物品。即Si&lt;=Sj且Vi&gt;Vj,则可去除j物品 </li>
</ol>
<h3 id="采用桶排序的方法筛选物品"><a href="#采用桶排序的方法筛选物品" class="headerlink" title="采用桶排序的方法筛选物品"></a>采用桶排序的方法筛选物品</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Java代码：</span><br><span class="line"></span><br><span class="line">public HashMap&lt;Integer,Integer&gt; DataCleaning(int[] goodsCa,int[] value,int capacity)&#123;</span><br><span class="line">    if(goodsCa.length !=value.length)&#123;</span><br><span class="line">        System.out.println(&quot;输入不匹配&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; result=new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        //建桶</span><br><span class="line">        int[] count=new int[capacity+1];</span><br><span class="line">        //填充</span><br><span class="line">        for(int i=0;i&lt;goodsCa.length;i++)&#123;</span><br><span class="line">            if(goodsCa[i]&lt;=capacity)&#123;</span><br><span class="line">                count[goodsCa[i]]=count[goodsCa[i]]&gt;value[i]?count[goodsCa[i]]:value[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //筛选</span><br><span class="line">        int tmp=0;</span><br><span class="line">        for(int i=1;i&lt;capacity+1;i++)&#123;</span><br><span class="line">            if(count[i]==0)</span><br><span class="line">                continue;</span><br><span class="line">            else if(count[i]&gt;tmp)&#123;</span><br><span class="line">                tmp=count[i];</span><br><span class="line">                result.put(i,count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                count[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set=result.KeySet();</span><br><span class="line">        for(Integer g:set)&#123;</span><br><span class="line">            System.out.println(g+&quot;,&quot;+result.get(g));</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻"><a href="#要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻" class="headerlink" title="要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻"></a>要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻</h3><h3 id="通用数据寄存器组"><a href="#通用数据寄存器组" class="headerlink" title="通用数据寄存器组"></a><strong>通用数据寄存器组</strong></h3><p>四个16位：<br>AX（累加器<br>BX（基地址存储器<br>CX（计数器<br>DX（数据存储器</p>
<p>八个8位:<br>AH/AL<br>BH/BL<br>CH/CL<br>DH/DL  </p>
<h3 id="指示器和变址寄存器组"><a href="#指示器和变址寄存器组" class="headerlink" title="指示器和变址寄存器组"></a><strong>指示器和变址寄存器组</strong></h3><p>它们四个都是16位的</p>
<p><strong>指示器</strong><br>所谓指示器，你可以把想象成链表的指针域，总是指向下一个结点的位置，总而言之，就是一个指示当前位置的标记</p>
<ol>
<li>SP（Stack Pointer）堆栈指示器<br>用于指示堆栈的栈顶位置和段落寄存器SS一起形成的堆栈的顶端，SP始终指向栈顶位置。<br>这里要说一下，<strong>堆栈是倒挂的生长的</strong>，比如说从10000H到100FFH的这个地址空间，SS=1000H（10000H），设SP=000FH（1000FH），每push一个字，SP先减2再填充字，比如push 1024H，此时SP=000DH（1000DH）。你看它是从高地址往低地址走的，这也是我为什么说它是倒挂的原因。<br>（段寄存器在下面会介绍一下，如果你不明白为什么会有段寄存器的话可以去查查，好吧，我在这里也写一写）<br>众所周知，8086的内外部数据总线均为16位，但它的地址总线却有20位，寻址范围为1M字节的存储空间。<br>而8086系统中存储器按字节编码，显然对应的地址为00000H-FFFFFH，但是你数据总线只有16位啊（64K的寻址能力），这怎么办？答案是拆分，比如把8FFFFH拆成80000H+FFFFH，80000H怎么表示？通过移位来解决，比如一个寄存器的值为8000H，然后用一个20位的加法器把8000H放到高16位，低四位全部赋值为0，这样80000H就出现了。这个存着8000H的寄存器就可以认为是段寄存器，所谓段就是把1M字节分成16段，每段达到数据线的最大寻址能力64K，你想想1M除以64K等于多少？段寄存器就是来表示要寻找的在哪段里!!!</li>
<li>BP（Base Pointer）基址指示器<br>BP是用作堆栈的一个附加指针，与SS联用，确定堆栈中某一存储单元的物理地址。<br>与SP的区别是SP始终<strong>指向栈顶</strong>，BP可以指向栈的<strong>任意位子</strong>。</li>
</ol>
<p><strong>变址寄存器</strong>  </p>
<ol>
<li>SI（Source Index）源变址寄存器  </li>
<li>DI（Destination Index）目标变址寄存器<br>变址变址，就是会自己动，这两个寄存器有自动增和自动减的功能，常与DS和ES段寄存器联用。SI表示源地址，DI表示目标地址<h3 id="FLAGS标志寄存器"><a href="#FLAGS标志寄存器" class="headerlink" title="FLAGS标志寄存器"></a><strong>FLAGS标志寄存器</strong></h3> OF/DF/IF/TF/SF/ZF/AF/PF/CF<h3 id="指令指针寄存器IP（Instruction-Pointer"><a href="#指令指针寄存器IP（Instruction-Pointer" class="headerlink" title="指令指针寄存器IP（Instruction Pointer)"></a><strong>指令指针寄存器IP（Instruction Pointer)</strong></h3> 为了取指令用的，IP内容为当前代码段内偏移量，你想想你写了许多行的代码，这一行行的代码其实就是一条条的汇编指令，你总要一条条执行吧，因此你必须要一条条的读取指令，当然有跳转的时候另说。<br> IP与CS一起形成要取出的指令操作码的存储单元的20位地址，每取一个字节IP自动加1</li>
</ol>
<h2 id="8086指令"><a href="#8086指令" class="headerlink" title="8086指令"></a>8086指令</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><pre><code>指示计算机进行某种操作的命令，简单说就是你写的代码要执行的操作</code></pre><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre><code>操作码 [目的操作数],[源操作数]

操作数一般分3类
1. 立即数操作数
只能用作源操作数，不能作为目的操作数
2.寄存器操作数
操作数存放在CPU的寄存器中（通用寄存器，专用寄存器，段寄存器，上面CPU图中的大都可以）
3.存储器操作数
存放在内存或外存里的数据</code></pre><h3 id="寻址方式（重头戏，反复看就能记住了）"><a href="#寻址方式（重头戏，反复看就能记住了）" class="headerlink" title="寻址方式（重头戏，反复看就能记住了）"></a>寻址方式（重头戏，反复看就能记住了）</h3><h3 id="总共7种"><a href="#总共7种" class="headerlink" title="总共7种!!!"></a>总共7种!!!</h3><pre><code>段寄存器

CS（code segment）相应的偏移量由IP提供
DS（data segment）
ES（extra segment）指出当前程序使用的附加数据段的段基址
SS（stack segment）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.立即数寻址</span><br><span class="line">指令所用的8位或16位操作数作为指令的一部分</span><br><span class="line">例：</span><br><span class="line">MOV CL，64H</span><br><span class="line">就是将64H送入CL</span><br><span class="line">立即数只能是源操作数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2.直接寻址（Direct Addressing）</span><br><span class="line">这是对存储器进行访问的最简单的方式，因为直接寻址直接给出了操作数的16位偏移地址</span><br><span class="line">直接寻址默认的段前缀为DS（数据段）</span><br><span class="line">例：</span><br><span class="line">MOV BX，[2040H]  将DS段的偏移地址为2040H和2041H的两字节单元的内容送给BX寄存器，设DS=2000H，就是地址为22040H和22041H的两单元的内容</span><br><span class="line"></span><br><span class="line">如果加了段前缀呢？</span><br><span class="line">MOV BX，ES:[2040H]</span><br><span class="line">那么就从ES段的2040H开始啦！ES*16+2040H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3.寄存器寻址</span><br><span class="line">操作数存放在CPU内部的寄存器中，不在存储器！</span><br><span class="line">16位的寄存器可以是</span><br><span class="line">AX/BX/CX/DX/SI/DI/SP/BP</span><br><span class="line">8位</span><br><span class="line">AH/AL/BH/BL/CH/CL/DH/DL</span><br><span class="line">如</span><br><span class="line">MOV DX，AX  把AX寄存器的内容给DX</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4.寄存器间接寻址</span><br><span class="line">简单说就是把寄存器里存的数据当成存储器的偏移地址</span><br><span class="line">不过有效地址一般存在BX/BP和SI/DI寄存器里</span><br><span class="line">使用BX/SI/DI时的段前缀为DS</span><br><span class="line">使用BP为SS</span><br><span class="line">或者你可以指定段前缀</span><br><span class="line">例</span><br><span class="line">MOV AX.[BX] 设DS=2000H，BX=1000H，存储器21000H字单元内容为1111H，则AX的内容等于1111H</span><br><span class="line">MOV AX.[BP] 设SS=3000H，BP=1000H。。。</span><br><span class="line">MOV AX,ES:[BX]  设ES=4000H，BX=1000H。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5.寄存器相对寻址（Register Relative Addressing）</span><br><span class="line">操作数的有效地址是一个基址或变址寄存器的内容加上指定的8位或16位位移量</span><br><span class="line">人话：就是BX/BP/SI/DI的内容先加一个数，然后再作为存储器的偏移地址</span><br><span class="line">段前缀和上一个一样</span><br><span class="line">例</span><br><span class="line">MOV AX,COUNT[DI] (MOV AX,[DI+COUNT])</span><br><span class="line">设DI=1000H,COUNT=4000H,DS=3000H</span><br><span class="line">30000+1000+4000=35000H</span><br><span class="line">若35000h存的字位1990H，则AX=1990H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6.基址变址寻址</span><br><span class="line">有效地址是一个基址寄存器和一个变址寄存器的和</span><br><span class="line">人话：BX/BP   +   DI/SI</span><br><span class="line">例：</span><br><span class="line">MOV AX,[BX][DI] (MOV AX,[BX+DI])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.相对基址变址寻址</span><br><span class="line">人话：就是BX/BP  +   DI/SI  + 一个普通的数</span><br><span class="line">例：</span><br><span class="line">MOV AX,[BX+SI+0080H]</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/26/8086CPU%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Liu Rong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/26/8086CPU%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/" itemprop="url">8086CPU的寻址方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-26T09:14:40+08:00">
                2019-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>我之所以写这篇文章是因为我总是记不住它们的概念，什么相对寻址啊，变址寻址啊，乱七八糟的，总是看了忘忘了看，这里就不得不说我作为一个弱鸡的悲哀，上学期学过汇编，看过王爽老师的汇编书，然而还是菜的一匹，所以这次想把它们一网打尽–_–</p>
<h1 id="话不多说了，我们直接来看看它到底是什么妖魔鬼怪"><a href="#话不多说了，我们直接来看看它到底是什么妖魔鬼怪" class="headerlink" title="话不多说了，我们直接来看看它到底是什么妖魔鬼怪"></a>话不多说了，我们直接来看看它到底是什么妖魔鬼怪</h1><h2 id="8086CPU"><a href="#8086CPU" class="headerlink" title="8086CPU"></a>8086CPU</h2><!-- ![8086CPU](images/8086CPU.png) -->
<img src="/2019/10/26/8086CPU%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/8086CPU.png" class>

<h3 id="要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻"><a href="#要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻" class="headerlink" title="要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻"></a>要搞懂它的寻址方式，我们必须要先了解它相关的寄存器的概念，嘻嘻</h3><h3 id="通用数据寄存器组"><a href="#通用数据寄存器组" class="headerlink" title="通用数据寄存器组"></a><strong>通用数据寄存器组</strong></h3><p>四个16位：<br>AX（累加器<br>BX（基地址存储器<br>CX（计数器<br>DX（数据存储器</p>
<p>八个8位:<br>AH/AL<br>BH/BL<br>CH/CL<br>DH/DL  </p>
<h3 id="指示器和变址寄存器组"><a href="#指示器和变址寄存器组" class="headerlink" title="指示器和变址寄存器组"></a><strong>指示器和变址寄存器组</strong></h3><p>它们四个都是16位的</p>
<p><strong>指示器</strong><br>所谓指示器，你可以把想象成链表的指针域，总是指向下一个结点的位置，总而言之，就是一个指示当前位置的标记</p>
<ol>
<li>SP（Stack Pointer）堆栈指示器<br>用于指示堆栈的栈顶位置和段落寄存器SS一起形成的堆栈的顶端，SP始终指向栈顶位置。<br>这里要说一下，<strong>堆栈是倒挂的生长的</strong>，比如说从10000H到100FFH的这个地址空间，SS=1000H（10000H），设SP=000FH（1000FH），每push一个字，SP先减2再填充字，比如push 1024H，此时SP=000DH（1000DH）。你看它是从高地址往低地址走的，这也是我为什么说它是倒挂的原因。<br>（段寄存器在下面会介绍一下，如果你不明白为什么会有段寄存器的话可以去查查，好吧，我在这里也写一写）<br>众所周知，8086的内外部数据总线均为16位，但它的地址总线却有20位，寻址范围为1M字节的存储空间。<br>而8086系统中存储器按字节编码，显然对应的地址为00000H-FFFFFH，但是你数据总线只有16位啊（64K的寻址能力），这怎么办？答案是拆分，比如把8FFFFH拆成80000H+FFFFH，80000H怎么表示？通过移位来解决，比如一个寄存器的值为8000H，然后用一个20位的加法器把8000H放到高16位，低四位全部赋值为0，这样80000H就出现了。这个存着8000H的寄存器就可以认为是段寄存器，所谓段就是把1M字节分成16段，每段达到数据线的最大寻址能力64K，你想想1M除以64K等于多少？段寄存器就是来表示要寻找的在哪段里!!!</li>
<li>BP（Base Pointer）基址指示器<br>BP是用作堆栈的一个附加指针，与SS联用，确定堆栈中某一存储单元的物理地址。<br>与SP的区别是SP始终<strong>指向栈顶</strong>，BP可以指向栈的<strong>任意位子</strong>。</li>
</ol>
<p><strong>变址寄存器</strong>  </p>
<ol>
<li>SI（Source Index）源变址寄存器  </li>
<li>DI（Destination Index）目标变址寄存器<br>变址变址，就是会自己动，这两个寄存器有自动增和自动减的功能，常与DS和ES段寄存器联用。SI表示源地址，DI表示目标地址<h3 id="FLAGS标志寄存器"><a href="#FLAGS标志寄存器" class="headerlink" title="FLAGS标志寄存器"></a><strong>FLAGS标志寄存器</strong></h3> OF/DF/IF/TF/SF/ZF/AF/PF/CF<h3 id="指令指针寄存器IP（Instruction-Pointer"><a href="#指令指针寄存器IP（Instruction-Pointer" class="headerlink" title="指令指针寄存器IP（Instruction Pointer)"></a><strong>指令指针寄存器IP（Instruction Pointer)</strong></h3> 为了取指令用的，IP内容为当前代码段内偏移量，你想想你写了许多行的代码，这一行行的代码其实就是一条条的汇编指令，你总要一条条执行吧，因此你必须要一条条的读取指令，当然有跳转的时候另说。<br> IP与CS一起形成要取出的指令操作码的存储单元的20位地址，每取一个字节IP自动加1</li>
</ol>
<h2 id="8086指令"><a href="#8086指令" class="headerlink" title="8086指令"></a>8086指令</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><pre><code>指示计算机进行某种操作的命令，简单说就是你写的代码要执行的操作</code></pre><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><pre><code>操作码 [目的操作数],[源操作数]

操作数一般分3类
1. 立即数操作数
只能用作源操作数，不能作为目的操作数
2.寄存器操作数
操作数存放在CPU的寄存器中（通用寄存器，专用寄存器，段寄存器，上面CPU图中的大都可以）
3.存储器操作数
存放在内存或外存里的数据</code></pre><h3 id="寻址方式（重头戏，反复看就能记住了）"><a href="#寻址方式（重头戏，反复看就能记住了）" class="headerlink" title="寻址方式（重头戏，反复看就能记住了）"></a>寻址方式（重头戏，反复看就能记住了）</h3><h3 id="总共7种"><a href="#总共7种" class="headerlink" title="总共7种!!!"></a>总共7种!!!</h3><pre><code>段寄存器

CS（code segment）相应的偏移量由IP提供
DS（data segment）
ES（extra segment）指出当前程序使用的附加数据段的段基址
SS（stack segment）</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.立即数寻址</span><br><span class="line">指令所用的8位或16位操作数作为指令的一部分</span><br><span class="line">例：</span><br><span class="line">MOV CL，64H</span><br><span class="line">就是将64H送入CL</span><br><span class="line">立即数只能是源操作数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2.直接寻址（Direct Addressing）</span><br><span class="line">这是对存储器进行访问的最简单的方式，因为直接寻址直接给出了操作数的16位偏移地址</span><br><span class="line">直接寻址默认的段前缀为DS（数据段）</span><br><span class="line">例：</span><br><span class="line">MOV BX，[2040H]  将DS段的偏移地址为2040H和2041H的两字节单元的内容送给BX寄存器，设DS=2000H，就是地址为22040H和22041H的两单元的内容</span><br><span class="line"></span><br><span class="line">如果加了段前缀呢？</span><br><span class="line">MOV BX，ES:[2040H]</span><br><span class="line">那么就从ES段的2040H开始啦！ES*16+2040H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3.寄存器寻址</span><br><span class="line">操作数存放在CPU内部的寄存器中，不在存储器！</span><br><span class="line">16位的寄存器可以是</span><br><span class="line">AX/BX/CX/DX/SI/DI/SP/BP</span><br><span class="line">8位</span><br><span class="line">AH/AL/BH/BL/CH/CL/DH/DL</span><br><span class="line">如</span><br><span class="line">MOV DX，AX  把AX寄存器的内容给DX</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4.寄存器间接寻址</span><br><span class="line">简单说就是把寄存器里存的数据当成存储器的偏移地址</span><br><span class="line">不过有效地址一般存在BX/BP和SI/DI寄存器里</span><br><span class="line">使用BX/SI/DI时的段前缀为DS</span><br><span class="line">使用BP为SS</span><br><span class="line">或者你可以指定段前缀</span><br><span class="line">例</span><br><span class="line">MOV AX.[BX] 设DS=2000H，BX=1000H，存储器21000H字单元内容为1111H，则AX的内容等于1111H</span><br><span class="line">MOV AX.[BP] 设SS=3000H，BP=1000H。。。</span><br><span class="line">MOV AX,ES:[BX]  设ES=4000H，BX=1000H。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5.寄存器相对寻址（Register Relative Addressing）</span><br><span class="line">操作数的有效地址是一个基址或变址寄存器的内容加上指定的8位或16位位移量</span><br><span class="line">人话：就是BX/BP/SI/DI的内容先加一个数，然后再作为存储器的偏移地址</span><br><span class="line">段前缀和上一个一样</span><br><span class="line">例</span><br><span class="line">MOV AX,COUNT[DI] (MOV AX,[DI+COUNT])</span><br><span class="line">设DI=1000H,COUNT=4000H,DS=3000H</span><br><span class="line">30000+1000+4000=35000H</span><br><span class="line">若35000h存的字位1990H，则AX=1990H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6.基址变址寻址</span><br><span class="line">有效地址是一个基址寄存器和一个变址寄存器的和</span><br><span class="line">人话：BX/BP   +   DI/SI</span><br><span class="line">例：</span><br><span class="line">MOV AX,[BX][DI] (MOV AX,[BX+DI])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.相对基址变址寻址</span><br><span class="line">人话：就是BX/BP  +   DI/SI  + 一个普通的数</span><br><span class="line">例：</span><br><span class="line">MOV AX,[BX+SI+0080H]</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/VscodeReDev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Liu Rong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/23/VscodeReDev/" itemprop="url">VscodeRemoteDevelopment</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-23T14:03:07+08:00">
                2019-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="英语可以的话强烈建议直接去Vscode官网学习，我个人写的略浅薄"><a href="#英语可以的话强烈建议直接去Vscode官网学习，我个人写的略浅薄" class="headerlink" title="英语可以的话强烈建议直接去Vscode官网学习，我个人写的略浅薄"></a>英语可以的话强烈建议直接去<a href="https://code.visualstudio.com/docs/remote/remote-overview" target="_blank" rel="noopener">Vscode官网</a>学习，我个人写的略浅薄</h1><h2 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h2><p><a href="https://cloud.tencent.com/act/campus?fromSource=gwzcw.1296287.1296287.1296287" target="_blank" rel="noopener">腾讯云</a>  </p>
<p><a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云</a>  </p>
<!-- ![阿里云服务器选择图](images/1.jpg)   -->
<img src="/2019/10/23/VscodeReDev/1.jpg" class>

<!-- <img src="/2019/10/23/VscodeReDev/1.jpg" class=""> -->
<blockquote>
<p>如上图所示</p>
</blockquote>
<p>选择系统镜像，系统选ubuntu，完成购买</p>
<blockquote>
<p>进入右上角控制台</p>
</blockquote>
<p>点击云服务器，可查看自己的设备<br>更改密码（可选），更改完成后重启服务器</p>
<blockquote>
<p>点击登陆（立即登录）</p>
</blockquote>
<p>默认名为ubuntu，是否更改（自选）<br>登陆完成，进入自己的服务器</p>
<h2 id="SSH简介及使用"><a href="#SSH简介及使用" class="headerlink" title="SSH简介及使用"></a>SSH简介及使用</h2><blockquote>
<p>SSH</p>
</blockquote>
<p>SSH(Security Shell) 是用来实现安全远程管理的一个协议，通过加密方式保障信息安全</p>
<p>SSH工具分为客户端（本机）和服务端（云服务器）</p>
<blockquote>
<p>客户端</p>
</blockquote>
<p><strong>安装SSH Client</strong><br>Win10在桌面左下角输入powershell，选择管理员身份运行  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入  </span><br><span class="line">Get-WindowsCapability -Online | ? Name -like <span class="string">'OpenSSH'</span>  </span><br><span class="line">查看你是否拥有OpenSSH-Client Or Server  </span><br><span class="line">大概率State:NotPresent  </span><br><span class="line">在本机中只需要安装Client,在远程中安装Server  </span><br><span class="line"></span><br><span class="line">安装Client  </span><br><span class="line">Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0  </span><br><span class="line">安装成功会出现以下结果</span><br><span class="line">Path      :</span><br><span class="line">Online    :True</span><br><span class="line">RestartNeeded:False</span><br></pre></td></tr></table></figure>
<p><strong>配置SSH公/私钥</strong><br>为什么要配置它？<br>一般SSH进行远程登陆是进行加密的，通过公钥私钥的配对来确保交流安全，确保与远程服务器连接的是本人<br>右下角打开cmd，输入cd …进入你的个人文件夹（也可以在桌面打开看看）  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例如我的</span><br><span class="line">c:</span><br><span class="line"><span class="built_in">cd</span> /user/klr10</span><br><span class="line">进入里面会有个.ssh文件</span><br><span class="line">这就是你要存放公钥私钥的地方</span><br><span class="line">你可能会没有这个文件</span><br><span class="line">这时候你就要用git去创建一下了（可以网上搜一下这一步，我太懒了，写不动了）</span><br><span class="line"></span><br><span class="line">好了，我们来创建密钥（使用ssh-keygen命令-_-)跟我一步一步的</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">输入id_rsa</span><br><span class="line">然后设置密码，设置密码的时候啥都不显示，不要惊奇，它不会明文显示，ubuntu切换到root时要你输入密码时也是如此，这一步按两下回车，不要设密码也是可以的</span><br><span class="line"></span><br><span class="line">然后就好了，接着把你的id_rsa.pub文件拷到你的服务器中，这应该是公钥，当你进行远程连接时，它在服务器上与你进行配对，就是这个意思</span><br><span class="line">scp c:/user/klr10/.ssh/id_rsa.pub   你的用户名ubuntu@你的公网IP（在登陆选项那看）:/home/ubuntu/tmp.pub</span><br><span class="line">这句话就是拷贝了,你同时也在ubuntu上创建了tmp.pub这个档案，它存的就是公钥，路径我可能会打错，记不太清了，你看着增删就好了</span><br><span class="line"></span><br><span class="line">ssh 你的用户名ubuntu@你的公网IP <span class="string">"mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; cat ~/tmp.pub &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys &amp;&amp; rm -f ~/tmp.pub"</span></span><br><span class="line">这句话就是在ubuntu上创建个.ssh目录，创建个authorized_keys档案，把你刚弄的tmp.pub赋给它然后删除tmp.pub，这样做只是为了让文件层次更清晰</span><br><span class="line">linux命令自行百度谷歌</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/fb56fa3c233b" target="_blank" rel="noopener">linux-mkdir</a></p>
<blockquote>
<p>服务端</p>
</blockquote>
<p>安装ssh服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ssh</span><br><span class="line">```  </span><br><span class="line">开启ssh服务</span><br><span class="line">``` bash</span><br><span class="line">$ sudo service ssh start</span><br></pre></td></tr></table></figure>
<h2 id="Vscode远程连接"><a href="#Vscode远程连接" class="headerlink" title="Vscode远程连接"></a>Vscode远程连接</h2><p>打开Vscode，安装插件remote development,它是三合一的东西<br>在左侧工具栏会出现Remote-SSH的图标，点击它，出现connections,点击加下划线额东西可以开始配置了<br>Host kang<br>    HostName 你的公网IP<br>    User 你的主机名</p>
<p>ctrl+s保存<br>开始享受连接，会出现一个新窗口，点击Open File你会发现linux文件可视化了，选择/home/ubuntu 点击OK，开始工作吧<br>点击菜单栏的Terminal的new Terminal可以打开命令行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kang Liu Rong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/23/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-23T08:37:00+08:00">
                2019-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Kang Liu Rong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kang Liu Rong</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
